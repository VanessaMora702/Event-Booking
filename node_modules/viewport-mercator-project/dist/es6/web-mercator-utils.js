function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function _iterableToArrayLimit(arr,i){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _s,_i=arr[Symbol.iterator]();!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!(i&&_arr.length===i));_n=!0);}catch(err){_d=!0,_e=err}finally{try{_n||null==_i["return"]||_i["return"]()}finally{if(_d)throw _e}}return _arr}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}import{Vector3}from"math.gl";import{createMat4,transformVector}from"./math-utils";import mat4_perspective from"gl-mat4/perspective";import mat4_scale from"gl-mat4/scale";import mat4_translate from"gl-mat4/translate";import mat4_rotateX from"gl-mat4/rotateX";import mat4_rotateZ from"gl-mat4/rotateZ";import vec2_lerp from"gl-vec2/lerp";import assert from"./assert";const PI=Math.PI,PI_4=PI/4,DEGREES_TO_RADIANS=PI/180,RADIANS_TO_DEGREES=180/PI,TILE_SIZE=512,EARTH_CIRCUMFERENCE=4003e4,DEFAULT_ALTITUDE=1.5;export function zoomToScale(zoom){return Math.pow(2,zoom)}export function scaleToZoom(scale){return Math.log2(scale)}export function lngLatToWorld([lng,lat],scale){scale*=TILE_SIZE;const x=scale*(lng*DEGREES_TO_RADIANS+PI)/(2*PI),y=scale*(PI-Math.log(Math.tan(PI_4+.5*(lat*DEGREES_TO_RADIANS))))/(2*PI);return[x,y]}export function worldToLngLat([x,y],scale){scale*=TILE_SIZE;const lambda2=x/scale*(2*PI)-PI,phi2=2*(Math.atan(Math.exp(PI-y/scale*(2*PI)))-PI_4);return[lambda2*RADIANS_TO_DEGREES,phi2*RADIANS_TO_DEGREES]}export function getMeterZoom({latitude}){assert(Number.isFinite(latitude));const latCosine=Math.cos(latitude*DEGREES_TO_RADIANS);return scaleToZoom(EARTH_CIRCUMFERENCE*latCosine)-9}export function getDistanceScales({latitude,longitude,zoom,scale,highPrecision=!1}){var _NumberisFinite=Number.isFinite;scale=void 0===scale?zoomToScale(zoom):scale,assert(_NumberisFinite(latitude)&&_NumberisFinite(longitude)&&_NumberisFinite(scale));const result={},worldSize=TILE_SIZE*scale,latCosine=Math.cos(latitude*DEGREES_TO_RADIANS),pixelsPerDegreeX=worldSize/360,pixelsPerDegreeY=pixelsPerDegreeX/latCosine,altPixelsPerMeter=worldSize/EARTH_CIRCUMFERENCE/latCosine;if(result.pixelsPerMeter=[altPixelsPerMeter,altPixelsPerMeter,altPixelsPerMeter],result.metersPerPixel=[1/altPixelsPerMeter,1/altPixelsPerMeter,1/altPixelsPerMeter],result.pixelsPerDegree=[pixelsPerDegreeX,pixelsPerDegreeY,altPixelsPerMeter],result.degreesPerPixel=[1/pixelsPerDegreeX,1/pixelsPerDegreeY,1/altPixelsPerMeter],highPrecision){const latCosine2=DEGREES_TO_RADIANS*Math.tan(latitude*DEGREES_TO_RADIANS)/latCosine,altPixelsPerDegree2=worldSize/EARTH_CIRCUMFERENCE*latCosine2,altPixelsPerMeter2=altPixelsPerDegree2/pixelsPerDegreeY*altPixelsPerMeter;result.pixelsPerDegree2=[0,pixelsPerDegreeX*latCosine2/2,altPixelsPerDegree2],result.pixelsPerMeter2=[altPixelsPerMeter2,0,altPixelsPerMeter2]}return result}export function getWorldPosition({longitude,latitude,zoom,scale,meterOffset,distanceScales=null}){scale=scale===void 0?zoomToScale(zoom):scale;const center2d=lngLatToWorld([longitude,latitude],scale),center=new Vector3(center2d[0],center2d[1],0);if(meterOffset){distanceScales=distanceScales||getDistanceScales({latitude,longitude,scale});const pixelPosition=new Vector3(meterOffset).scale(distanceScales.pixelsPerMeter).scale([1,-1,1]);center.add(pixelPosition)}return center}export function getViewMatrix({height,pitch,bearing,altitude,center=null,flipY=!1}){const vm=createMat4();return mat4_translate(vm,vm,[0,0,-altitude]),mat4_scale(vm,vm,[1,1,1/height]),mat4_rotateX(vm,vm,-pitch*DEGREES_TO_RADIANS),mat4_rotateZ(vm,vm,bearing*DEGREES_TO_RADIANS),flipY&&mat4_scale(vm,vm,[1,-1,1]),center&&mat4_translate(vm,vm,new Vector3(center).negate()),vm}export function getProjectionParameters({width,height,altitude=DEFAULT_ALTITUDE,pitch=0,farZMultiplier=1}){var _MathPI=Math.PI,_Mathsin=Math.sin,_Mathatan=Math.atan;const pitchRadians=pitch*DEGREES_TO_RADIANS,halfFov=_Mathatan(.5/altitude),topHalfSurfaceDistance=_Mathsin(halfFov)*altitude/_Mathsin(_MathPI/2-pitchRadians-halfFov),farZ=Math.cos(_MathPI/2-pitchRadians)*topHalfSurfaceDistance+altitude;return{fov:2*_Mathatan(height/2/altitude),aspect:width/height,focalDistance:altitude,near:.1,far:farZ*farZMultiplier}}export function getProjectionMatrix({width,height,pitch,altitude,farZMultiplier=10}){const _getProjectionParamet=getProjectionParameters({width,height,altitude,pitch,farZMultiplier}),fov=_getProjectionParamet.fov,aspect=_getProjectionParamet.aspect,near=_getProjectionParamet.near,far=_getProjectionParamet.far,projectionMatrix=mat4_perspective([],fov,aspect,near,far);return projectionMatrix}export function worldToPixels(xyz,pixelProjectionMatrix){var _NumberisFinite2=Number.isFinite;const _xyz=_slicedToArray(xyz,3),x=_xyz[0],y=_xyz[1],_xyz$=_xyz[2],z=void 0===_xyz$?0:_xyz$;return assert(_NumberisFinite2(x)&&_NumberisFinite2(y)&&_NumberisFinite2(z)),transformVector(pixelProjectionMatrix,[x,y,z,1])}export function pixelsToWorld(xyz,pixelUnprojectionMatrix,targetZ=0){var _NumberisFinite3=Number.isFinite;const _xyz2=_slicedToArray(xyz,3),x=_xyz2[0],y=_xyz2[1],z=_xyz2[2];if(assert(_NumberisFinite3(x)&&_NumberisFinite3(y)),_NumberisFinite3(z)){const coord=transformVector(pixelUnprojectionMatrix,[x,y,z,1]);return coord}const coord0=transformVector(pixelUnprojectionMatrix,[x,y,0,1]),coord1=transformVector(pixelUnprojectionMatrix,[x,y,1,1]),z0=coord0[2],z1=coord1[2],t=z0===z1?0:((targetZ||0)-z0)/(z1-z0);return vec2_lerp([],coord0,coord1,t)}
//# sourceMappingURL=web-mercator-utils.js.map