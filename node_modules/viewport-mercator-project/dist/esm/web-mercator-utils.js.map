{"version":3,"sources":["../../src/web-mercator-utils.js"],"names":["Vector3","createMat4","transformVector","mat4_perspective","mat4_scale","mat4_translate","mat4_rotateX","mat4_rotateZ","vec2_lerp","assert","PI","Math","PI_4","DEGREES_TO_RADIANS","RADIANS_TO_DEGREES","TILE_SIZE","EARTH_CIRCUMFERENCE","DEFAULT_ALTITUDE","zoomToScale","zoom","pow","scaleToZoom","scale","log2","lngLatToWorld","lng","lat","x","y","log","tan","worldToLngLat","lambda2","phi2","atan","exp","getMeterZoom","latitude","Number","isFinite","latCosine","cos","getDistanceScales","longitude","highPrecision","result","worldSize","pixelsPerDegreeX","pixelsPerDegreeY","altPixelsPerMeter","pixelsPerMeter","metersPerPixel","pixelsPerDegree","degreesPerPixel","latCosine2","altPixelsPerDegree2","altPixelsPerMeter2","pixelsPerDegree2","pixelsPerMeter2","getWorldPosition","meterOffset","distanceScales","center2d","center","pixelPosition","add","getViewMatrix","height","pitch","bearing","altitude","flipY","vm","negate","getProjectionParameters","sin","width","farZMultiplier","pitchRadians","halfFov","topHalfSurfaceDistance","farZ","fov","aspect","focalDistance","near","far","getProjectionMatrix","projectionMatrix","worldToPixels","xyz","pixelProjectionMatrix","z","pixelsToWorld","pixelUnprojectionMatrix","targetZ","coord","coord0","coord1","z0","z1","t"],"mappings":"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","sourcesContent":["// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE\n\nimport {Vector3} from 'math.gl';\nimport {createMat4, transformVector} from './math-utils';\n\nimport mat4_perspective from 'gl-mat4/perspective';\nimport mat4_scale from 'gl-mat4/scale';\nimport mat4_translate from 'gl-mat4/translate';\nimport mat4_rotateX from 'gl-mat4/rotateX';\nimport mat4_rotateZ from 'gl-mat4/rotateZ';\nimport vec2_lerp from 'gl-vec2/lerp';\nimport assert from './assert';\n\n// CONSTANTS\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n\n// Mapbox default altitude\nconst DEFAULT_ALTITUDE = 1.5;\n\n/** Util functions **/\nexport function zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\n\nexport function scaleToZoom(scale) {\n  return Math.log2(scale);\n}\n\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\nexport function lngLatToWorld([lng, lat], scale) {\n  scale *= TILE_SIZE;\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = scale * (lambda2 + PI) / (2 * PI);\n  const y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\n\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\nexport function worldToLngLat([x, y], scale) {\n  scale *= TILE_SIZE;\n  const lambda2 = (x / scale) * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(PI - (y / scale) * (2 * PI))) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n\n// Returns the zoom level that gives a 1 meter pixel at a certain latitude\n// 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)\nexport function getMeterZoom({latitude}) {\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales({latitude, longitude, zoom, scale, highPrecision = false}) {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : zoomToScale(zoom);\n\n  assert(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));\n\n  const result = {};\n  const worldSize = TILE_SIZE * scale;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const pixelsPerDegreeX = worldSize / 360;\n  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];\n\n  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];\n  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n     f'(a) * (x - a)\n       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;\n    const altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;\n\n    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}\n\n/**\n * Calculates a mercator world position (\"pixels\" in given zoom level)\n * from a lng/lat and meterOffset\n */\nexport function getWorldPosition({\n  longitude,\n  latitude,\n  zoom,\n  scale,\n  meterOffset,\n  distanceScales = null\n}) {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : zoomToScale(zoom);\n\n  // Make a centered version of the matrix for projection modes without an offset\n  const center2d = lngLatToWorld([longitude, latitude], scale);\n  const center = new Vector3(center2d[0], center2d[1], 0);\n\n  if (meterOffset) {\n    // Calculate distance scales if lng/lat/zoom are provided\n    distanceScales = distanceScales || getDistanceScales({latitude, longitude, scale});\n\n    const pixelPosition = new Vector3(meterOffset)\n      // Convert to pixels in current zoom\n      .scale(distanceScales.pixelsPerMeter)\n      // We want positive Y to represent an offset towards north,\n      // but web mercator world coordinates is top-left\n      .scale([1, -1, 1]);\n    center.add(pixelPosition);\n  }\n\n  return center;\n}\n\n// ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\n\nexport function getViewMatrix({\n  // Viewport props\n  height,\n  pitch,\n  bearing,\n  altitude,\n  // Pre-calculated parameters\n  center = null,\n  // Options\n  flipY = false\n}) {\n\n  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES\n  // Note that mercator world coordinates typically need to be flipped\n  //\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n  const vm = createMat4();\n\n  // Move camera to altitude (along the pitch & bearing direction)\n  mat4_translate(vm, vm, [0, 0, -altitude]);\n\n  // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n  mat4_scale(vm, vm, [1, 1, 1 / height]);\n\n  // Rotate by bearing, and then by pitch (which tilts the view)\n  mat4_rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  mat4_rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n\n  if (flipY) {\n    mat4_scale(vm, vm, [1, -1, 1]);\n  }\n\n  if (center) {\n    mat4_translate(vm, vm, new Vector3(center).negate());\n  }\n\n  return vm;\n}\n\n// PROJECTION MATRIX PARAMETERS\n// This is a \"Mapbox\" projection matrix - matches mapbox exactly if farZMultiplier === 1\n// Variable fov (in radians)\nexport function getProjectionParameters({\n  width,\n  height,\n  altitude = DEFAULT_ALTITUDE,\n  pitch = 0,\n  farZMultiplier = 1\n}) {\n  // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const halfFov = Math.atan(0.5 / altitude);\n  const topHalfSurfaceDistance =\n    Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);\n\n  // Calculate z value of the farthest fragment that should be rendered.\n  const farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n\n  return {\n    fov: 2 * Math.atan((height / 2) / altitude),\n    aspect: width / height,\n    focalDistance: altitude,\n    near: 0.1,\n    far: farZ * farZMultiplier\n  };\n}\n\n// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE\n// This is a \"Mapbox\" projection matrix - matches mapbox exactly if farZMultiplier === 1\n// Variable fov (in radians)\nexport function getProjectionMatrix({\n  width,\n  height,\n  pitch,\n  altitude,\n  farZMultiplier = 10\n}) {\n  const {fov, aspect, near, far} =\n    getProjectionParameters({width, height, altitude, pitch, farZMultiplier});\n\n  const projectionMatrix = mat4_perspective(\n    [],\n    fov,      // fov in radians\n    aspect,   // aspect ratio\n    near,     // near plane\n    far       // far plane\n  );\n\n  return projectionMatrix;\n}\n\n/**\n * Project flat coordinates to pixels on screen.\n *\n * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile\n * @param {Matrix4} pixelProjectionMatrix - projection matrix\n * @return {Array} [x, y, depth] pixel coordinate on screen.\n */\nexport function worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\n\n/**\n * Unproject pixels on screen to flat coordinates.\n *\n * @param {Array} xyz - pixel coordinate on screen.\n * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix\n * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),\n *    targetZ is used as the elevation plane to unproject onto\n * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.\n */\nexport function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {\n  const [x, y, z] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y));\n\n  if (Number.isFinite(z)) {\n    // Has depth component\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  // since we don't know the correct projected z value for the point,\n  // unproject two points to get a line and then find the point on that line with z=0\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2_lerp([], coord0, coord1, t);\n}\n"],"file":"web-mercator-utils.js"}