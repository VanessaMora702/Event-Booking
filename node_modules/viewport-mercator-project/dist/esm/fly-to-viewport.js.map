{"version":3,"sources":["../../src/fly-to-viewport.js"],"names":["Vector2","lerp","scaleToZoom","zoomToScale","lngLatToWorld","worldToLngLat","EPSILON","VIEWPORT_TRANSITION_PROPS","flyToViewport","startProps","endProps","t","Math","cosh","log","sqrt","viewport","rho","startZoom","zoom","startCenter","longitude","latitude","startScale","endZoom","endCenter","scale","startCenterXY","endCenterXY","uDelta","subtract","w0","max","width","height","w1","u1","x","y","abs","key","startValue","endValue","rho2","b0","b1","r0","r1","s","w","u","tanh","sinh","scaleIncrement","newZoom","newCenter","add"],"mappings":"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","sourcesContent":["import {Vector2} from 'math.gl';\nimport {lerp} from './math-utils';\nimport {\n  scaleToZoom,\n  zoomToScale,\n  lngLatToWorld,\n  worldToLngLat\n} from './web-mercator-utils';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n*/\n/* eslint-disable max-statements */\nexport default function flyToViewport(startProps, endProps, t) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  // TODO: add this as an option for applications.\n  const rho = 1.414;\n\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = new Vector2(lngLatToWorld(startCenter, startScale));\n  const endCenterXY = new Vector2(lngLatToWorld(endCenter, startScale));\n  const uDelta = endCenterXY.subtract(startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = Math.sqrt((uDelta.x * uDelta.x) + (uDelta.y * uDelta.y));\n  // u0 is treated as '0' in Eq (9).\n\n  // If change in center is too small, do linear interpolaiton.\n  if (Math.abs(u1) < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  const s = t * S;\n\n  const w = (Math.cosh(r0) / Math.cosh(r0 + rho * s));\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenter = worldToLngLat(\n    (startCenterXY.add(uDelta.scale(u))).scale(scaleIncrement),\n    zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n/* eslint-enable max-statements */\n"],"file":"fly-to-viewport.js"}