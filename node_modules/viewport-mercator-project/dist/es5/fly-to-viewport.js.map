{"version":3,"sources":["../../src/fly-to-viewport.js"],"names":["EPSILON","VIEWPORT_TRANSITION_PROPS","flyToViewport","startProps","endProps","t","viewport","rho","startZoom","zoom","startCenter","longitude","latitude","startScale","endZoom","endCenter","scale","startCenterXY","Vector2","endCenterXY","uDelta","subtract","w0","Math","max","width","height","w1","u1","sqrt","x","y","abs","key","startValue","endValue","rho2","b0","b1","r0","log","r1","S","s","w","cosh","u","tanh","sinh","scaleIncrement","newZoom","newCenter","add"],"mappings":"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","sourcesContent":["import {Vector2} from 'math.gl';\nimport {lerp} from './math-utils';\nimport {\n  scaleToZoom,\n  zoomToScale,\n  lngLatToWorld,\n  worldToLngLat\n} from './web-mercator-utils';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n*/\n/* eslint-disable max-statements */\nexport default function flyToViewport(startProps, endProps, t) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  // TODO: add this as an option for applications.\n  const rho = 1.414;\n\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = new Vector2(lngLatToWorld(startCenter, startScale));\n  const endCenterXY = new Vector2(lngLatToWorld(endCenter, startScale));\n  const uDelta = endCenterXY.subtract(startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = Math.sqrt((uDelta.x * uDelta.x) + (uDelta.y * uDelta.y));\n  // u0 is treated as '0' in Eq (9).\n\n  // If change in center is too small, do linear interpolaiton.\n  if (Math.abs(u1) < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n  const s = t * S;\n\n  const w = (Math.cosh(r0) / Math.cosh(r0 + rho * s));\n  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenter = worldToLngLat(\n    (startCenterXY.add(uDelta.scale(u))).scale(scaleIncrement),\n    zoomToScale(newZoom));\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n/* eslint-enable max-statements */\n"],"file":"fly-to-viewport.js"}