'use strict';

exports.__esModule = true;
exports.getStringifiedValue = exports.tryCatch = exports.getIntegerHashValue = exports.createReplacer = exports.getCircularStackValue = exports.getValueForStringification = exports.getStringifiedValueByObjectClass = exports.getStringifiedElement = exports.getTypePrefixedString = exports.getStringFromArrayBuffer = exports.getIterablePairs = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // external dependencies


// constants


var _jsonPrune = require('json-prune');

var _jsonPrune2 = _interopRequireDefault(_jsonPrune);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var toString = Object.prototype.toString;

/**
 * @function getIterablePairs
 *
 * @description
 * get the [key,value] pairs for maps and sets
 *
 * @param {Map|Set} iterable the iterable to map
 * @param {string} type the type of object class
 * @returns {Array<Array>} the [key, value] pairs
 */
var getIterablePairs = exports.getIterablePairs = function getIterablePairs(iterable, type) {
  var pairs = [_constants.OBJECT_CLASS_MAP[type]];

  iterable.forEach(function (item, key) {
    pairs.push([key, item]);
  });

  return pairs;
};

/**
 * @function getStringFromArrayBuffer
 *
 * @description
 * get the string value of the buffer passed
 *
 * @param {ArrayBuffer} buffer the array buffer to convert
 * @returns {string} the stringified buffer
 */
var getStringFromArrayBuffer = exports.getStringFromArrayBuffer = function getStringFromArrayBuffer(buffer) {
  return typeof Uint16Array === 'undefined' ? '' : String.fromCharCode.apply(null, new Uint16Array(buffer));
};
/**
 * @function getTypePrefixedString
 *
 * @description
 * prepend type to string value
 *
 * @param {string} string the string to prepend
 * @param {string} type the type to add as a prefix
 * @returns {string} the prefixed string
 */
var getTypePrefixedString = exports.getTypePrefixedString = function getTypePrefixedString(string, type) {
  return _constants.OBJECT_CLASS_MAP[type] + ' ' + string;
};

/**
 * @function getStringifiedElement
 *
 * @description
 * get the HTML element stringified by its type, attributes, and contents
 *
 * @param {HTMLElement} element the element to stringify
 * @returns {string} the stringified elements
 */
var getStringifiedElement = exports.getStringifiedElement = function getStringifiedElement(element) {
  var attributes = element.attributes;

  var attributesString = '';

  for (var index = 0; index < attributes.length; index++) {
    attributesString += attributes[index].name + '="' + attributes[index].value + '",';
  }

  return element.tagName + ' ' + attributesString + ' ' + element.innerHTML;
};

/**
 * @function getStringifiedValueByObjectClass
 *
 * @description
 * get the stringified value of the object based based on its toString class
 *
 * @param {*} object the object to get the stringification value for
 * @param {string} [passedObjectClass] the object class for the object passed
 * @returns {*} the value to stringify with
 */
var getStringifiedValueByObjectClass = exports.getStringifiedValueByObjectClass = function getStringifiedValueByObjectClass(object, passedObjectClass) {
  var objectClass = passedObjectClass || toString.call(object);

  if (~_constants.STRINGIFY_SELF_CLASSES.indexOf(objectClass)) {
    return object;
  }

  if (~_constants.STRINGIFY_PREFIX_CLASSES.indexOf(objectClass) || object === null) {
    return getTypePrefixedString(object, objectClass);
  }

  if (objectClass === _constants.OBJECT_CLASS_TYPE_MAP.DATE) {
    return getTypePrefixedString(object.valueOf(), objectClass);
  }

  if (~_constants.STRINGIFY_ITERABLE_CLASSES.indexOf(objectClass)) {
    return getIterablePairs(object, objectClass);
  }

  if (~_constants.STRINGIFY_NOT_ENUMERABLE_CLASSES.indexOf(objectClass)) {
    return getTypePrefixedString('NOT_ENUMERABLE', objectClass);
  }

  if (objectClass === _constants.OBJECT_CLASS_TYPE_MAP.ARRAYBUFFER) {
    return getTypePrefixedString(getStringFromArrayBuffer(object), objectClass);
  }

  if (objectClass === _constants.OBJECT_CLASS_TYPE_MAP.DATAVIEW) {
    return getTypePrefixedString(getStringFromArrayBuffer(object.buffer), objectClass);
  }

  if (~_constants.STRINGIFY_PREFIX_JOIN_CLASSES.indexOf(objectClass)) {
    return getTypePrefixedString(object.join(','), objectClass);
  }

  if (objectClass === _constants.OBJECT_CLASS_TYPE_MAP.MATH) {
    return _constants.MATH_OBJECT;
  }

  return _constants.HTML_ELEMENT_REGEXP.test(objectClass) ? getTypePrefixedString(getStringifiedElement(object), _constants.OBJECT_CLASS_TYPE_MAP.HTMLELEMENT) : object;
};

/**
 * @function getValueForStringification
 *
 * @description
 * get the string value for the object used for stringification
 *
 * @param {*} object the object to get the stringification value for
 * @returns {*} the value to stringify with
 */
var getValueForStringification = exports.getValueForStringification = function getValueForStringification(object) {
  var type = typeof object === 'undefined' ? 'undefined' : _typeof(object);

  if (~_constants.STRINGIFY_SELF_TYPES.indexOf(type)) {
    return object;
  }

  if (~_constants.STRINGIFY_PREFIX_TYPES.indexOf(type)) {
    return getTypePrefixedString(~_constants.STRINGIFY_TOSTRING_TYPES.indexOf(type) ? object.constructor.prototype.toString.call(object) : object, toString.call(object));
  }

  return getStringifiedValueByObjectClass(object);
};

/**
 * @function getCircularStackValue
 *
 * @description
 * get the value either from the recursive storage stack
 * or itself after being added to that stack
 *
 * @param {*} value the value to check for existing
 * @param {string} type the type of the value
 * @param {Array<*>} stack the current stack of values
 * @param {number} circularCounter the counter of circular references
 * @returns {*} the value to apply
 */
var getCircularStackValue = exports.getCircularStackValue = function getCircularStackValue(value, type, stack, circularCounter) {
  if (!value) {
    return getTypePrefixedString(value, type);
  }

  if (circularCounter > _constants.RECURSIVE_COUNTER_CUTOFF) {
    stack.length = 0;

    return value;
  }

  var existingIndex = stack.indexOf(value);

  if (!~existingIndex) {
    stack.push(value);

    return value;
  }

  return '*Circular-' + existingIndex;
};

/**
 * @function createReplacer
 *
 * @description
 * create the replacer function leveraging closure for recursive stack storage
 *
 * @param {Array<*>} stack the stack to store in memory
 * @returns {function} the replacer to use
 */
var createReplacer = exports.createReplacer = function createReplacer(stack) {
  var circularCounter = 1,
      objectClass = void 0;

  return function (key, value) {
    if (!key) {
      stack = [value];

      return value;
    }

    if (value === null) {
      return getStringifiedValueByObjectClass(value, _constants.OBJECT_CLASS_TYPE_MAP.NULL);
    }

    if (~_constants.STRINGIFY_TYPEOF_TYPES.indexOf(typeof value === 'undefined' ? 'undefined' : _typeof(value))) {
      return getValueForStringification(value);
    }

    objectClass = toString.call(value);

    if (~_constants.REPLACE_RECURSIVE_VALUE_CLASSES.indexOf(objectClass)) {
      return getCircularStackValue(value, objectClass, stack, ++circularCounter);
    }

    if (~_constants.REPLACE_STRINGIFICATION_CLASSES.indexOf(objectClass)) {
      return getStringifiedValueByObjectClass(value, objectClass);
    }

    return value;
  };
};

/**
 * @function getIntegerHashValue
 *
 * @description
 * based on string passed, get the integer hash value
 * through bitwise operation (based on spinoff of dbj2)
 *
 * @param {string} string the string to get the hash value for
 * @returns {number} the hash value
 */
var getIntegerHashValue = exports.getIntegerHashValue = function getIntegerHashValue(string) {
  if (!string) {
    return 0;
  }

  var hashValue = 5381;

  for (var index = 0; index < string.length; index++) {
    hashValue = (hashValue << 5) + hashValue + string.charCodeAt(index);
  }

  return hashValue >>> 0;
};

/**
 * @function tryCatch
 *
 * @description
 * move try/catch to standalone function as any function that contains a try/catch
 * is not optimized (this allows optimization for as much as possible)
 *
 * @param {*} value the value to stringify
 * @returns {string} the stringified value
 */
var tryCatch = exports.tryCatch = function tryCatch(value) {
  try {
    return JSON.stringify(value, createReplacer([]));
  } catch (exception) {
    return (0, _jsonPrune2.default)(value);
  }
};

/**
 * @function getStringifiedValue
 *
 * @description
 * stringify the object passed leveraging JSON.stringify
 * with REPLACER, falling back to prune
 *
 * @param {*} object the object to stringify
 * @param {boolean} isCircular is the object circular or not
 * @returns {string} the stringified object
 */
var getStringifiedValue = exports.getStringifiedValue = function getStringifiedValue(object, isCircular) {
  var valueForStringification = getValueForStringification(object);

  if (typeof valueForStringification === 'string') {
    return valueForStringification;
  }

  return isCircular ? tryCatch(getValueForStringification(object)) : JSON.stringify(valueForStringification, createReplacer([]));
};